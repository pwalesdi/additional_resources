{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Review Weeks 9 & 10 & 11\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Week 9 - Correlated Data "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### \"Rolling\" statistics through time, such as the rolling mean.\n",
    "- Rolling implies the idea of taking a moving range or window of values that is used for the calculation. \n",
    "- When applying a rolling statistic to say a time series dataset we may specify a time window, say 14 days, an perform the calculation for all possible window frames of 14 days.\n",
    "- Because we are not using the entirety of the dataset and only these windows, that stat is representative of the window in time **and** we make several calculations.\n",
    "    - **Window** indicates the number of days to include in the average.\n",
    "    - **Center** indicates whether the window should be centered on the date or use data prior to that date.\n",
    "    - **Freq** indicates which level to roll the averages up to (as used in resample): D for day, M for month, A for year, etc.\n",
    "- Lets think of an example.  \"Weekly rain fall volume\". This implies that we are measuring the rain fall of a 7 day period.  Additionally, this is a calculation that we're interested in measuring every day.  Because it is weekly, as days progress we can still only use the past 7 days for a calculation. \n",
    "\n",
    "**Rolling Total/AVG. Example Table**\n",
    "    \n",
    "| Date     | Rainfall | | Date     | Rainfall | | Date     | Rainfall | \n",
    "|:---------|----------|-|:---------|----------|-|:---------|----------|\n",
    "|Sept. 7   |  0       | |Sept. 8   | 0        ||Sept. 9   | 8.5      |\n",
    "|Sept. 6   | 1.5      ||Sept. 7   | 0        ||Sept. 8   | 0        |\n",
    "|Sept. 5   | 4        ||Sept. 6   | 1.5      ||Sept. 7   | 0        |\n",
    "|Sept. 4   | 0        ||Sept. 5   | 4        ||Sept. 6   | 1.5      |\n",
    "|Sept. 3   | 12       ||Sept. 4   | 0        ||Sept. 5   | 4        |\n",
    "|Sept. 2   | 0        ||Sept. 3   | 12       ||Sept. 4   | 0        |\n",
    "|Sept. 1   | 2.5      ||Sept. 2   | 0        ||Sept. 3   | 12       |\n",
    "|**Total** | **20**   ||**Total** | **17.5** ||**Total** | **26**   |\n",
    "|**Avg. ** | **2.85** ||**Avg. ** | **2.5**  ||**Avg. ** | **3.71** |\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Autocorrelation and partial autocorrelation\n",
    "\n",
    "**Autocorrelation**\n",
    "- AutoCorrelation looks at how much an observation in a series is correlated with a later or earlier observation. \n",
    "- AutoCorrelation takes 1 parameter `K` or `Lag` which is the value you are trying to calculate the correlation with.  A lag of 7 units (if our units were days) would indicate the previous same day of the week.  Such as Saturday to the previous Saturday or Wednesday to the previous Wednesday.\n",
    "    - A k of 365 (if our units were days) would indicate that date exactly one year ago.  Think Christmas or Halloween.\n",
    "\n",
    "**Partial Autocorrelation**\n",
    "- The Autocorrelation is a calculation for point $A_1$ and point $A_{1-k}$ and does not consider, in its calculation, the effects of all the observations that occur between $A_{1-k}$ and $A_1$.\n",
    "- The Partial Autocorrelation will take into consideration these values during its calculation.\n",
    "- This attempts to account for the fact that nearer observations tend to be more similar\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 648x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 648x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot  as plt\n",
    "from statsmodels.graphics.tsaplots import plot_acf, plot_pacf\n",
    "%matplotlib inline\n",
    "\n",
    "bus = pd.read_csv(\"../data/bus.csv\")\n",
    "bus.set_index('date', inplace=True)\n",
    "\n",
    "bus.index = pd.date_range('1/1/1973', # start date\n",
    "                          periods = len(bus.index), # we want the number of periods to match the length of our index\n",
    "                          freq = 'M')\n",
    "\n",
    "fig, ax = plt.subplots(figsize = (9, 5))\n",
    "plot_acf(bus['bus_ridership'], lags = 30, ax = ax)\n",
    "plt.show();\n",
    "\n",
    "fig, ax = plt.subplots(figsize = (9, 5))\n",
    "plot_pacf(bus['bus_ridership'], lags = 30, ax = ax)\n",
    "plt.show();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Describe when autoregressive models and moving average models are appropriate.\n",
    "\n",
    "**AutoRegression (AR)**\n",
    "- The models use previous observations as predictors.\n",
    "- Autoregressive models are used for modeling Long Term trends **not** sudden fluctuations.\n",
    "- AR models have a parameter \"`p`\" which indicates the number or previous observations to consider when making a prediction.\n",
    "    - We can look at the Autocorrelation viz in order to identify a \"`p`\" value to use.\n",
    "\n",
    "**Moving Average(MA)**\n",
    "- Moving average (MA) models take previous error terms as inputs. They predict the next value based on deviations from previous predictions. \n",
    "- We want to use MA models when there are sudden fluctuations in our process.\n",
    "- MA models have a parameter \"`q`\" which indicates the number or previous observations to consider when making a prediction.\n",
    "\n",
    "\n",
    "### Define stationarity.\n",
    "- A time series with a constant mean over time.\n",
    "- Has an autocorrelation that only depends on lag $k$, not on time $t$.\n",
    "- If you visualized the data it would have no clear upward or downward trend.  \n",
    "    - It may even have a consistent trend of events.\n",
    "\n",
    "### Conduct and interpret a Dickey-Fuller test for stationarity.\n",
    "- We can utilize the Dickey-Fuller test to test for stationarity.\n",
    "- This test is similar to a t-test in it outputs a p-value.\n",
    "    - This Null Hypothesis is that the data is **Not Stationary**\n",
    "        - Large P values support this hypothesis.\n",
    "    - The Alternate Hypothesis is that the data **is Stationary**\n",
    "        - Small P values support this hypothesis.\n",
    "        \n",
    "### Construct integrated autoregressive moving average (ARIMA) models.\n",
    "- Combining/_integrating_ an AR and MA model results in an ARIMA Model.\n",
    "- Useful when we want to model _longer term data with sudden fluctuations._\n",
    "    - Not Stationary.\n",
    "\n",
    "\n",
    "### Identify the optimal values of parameters $p$, $d$, and $q$.\n",
    "\n",
    "- Given that the ARMA and ARIMA models are statsmodels, we can not use gridsearch, so we just have to for loop it after taking a good hard look at the ARC and PARC charts\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Week 10 Bayes\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Intro to Bayes\n",
    "\n",
    "**Recognize and describe the axioms and properties of probability.**\n",
    "\n",
    "- Axioms\n",
    "    - Non-Negativity\n",
    "        - For any event, $A$, the probability of the event must be greater than or equal to zero.\n",
    "        - Can't have a negative probability (lamens) \n",
    "        - $0 <= P(A)$\n",
    "    - Additivity\n",
    "        - For mutual exclusive events, $e$, the probability of any of the events occuring is equivalnet to the sum of their probabilites\n",
    "        - The union of all probability is equal to their sum\n",
    "- Properties\n",
    "    - Propability of no event\n",
    "        - equals zero\n",
    "    - joint probability\n",
    "        - P(A|B) = multiply the probability that  BB  happens by the probability that  AA  occurs if  BB  does\n",
    "        - basis for likelihood and prior in numerator of Bayes Theorem $P(B|A)P(B)$\n",
    "    - Conditional probability\n",
    "        - basis for posterior $P(A|B)$\n",
    "        - target in Bayes Theorem\n",
    "        - intersection of probability of two condtional events over all possibility of one of the events \n",
    "    - Law of total probability\n",
    "        - bowl of cookies\n",
    "        - to get overall combine probabilities from different intersections\n",
    "\n",
    "**Describe Bayes' theorem.**\n",
    "$$ P(A|B) = \\frac{P(B|A)\\;P(A)}{P(B)} $$\n",
    "\n",
    "\n",
    "\n",
    "**Explain the diachronic interpretation of Bayes' theorem.**\n",
    "- The Prior $P(A)$\n",
    "    - The prior is our belief in the model given no additional information.\n",
    "- The Likelihood $P(B|A)$\n",
    "    - The likelihood is the probability of the data we observed occurring given the model\n",
    "    - Will influence our Prior\n",
    "- The Posterior $P(A|B)$\n",
    "    - Conditional probability\n",
    "    - What we are lloking for\n",
    "- The Marginal Probability $P(B)$\n",
    "    - data is the probability that our data are observed regardless of what model\n",
    "    - total probability where our event occurred\n",
    "\n",
    "**Solve some Bayesian statistics problems.**\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- P(has|with)\n",
    "- P(have|with)\n",
    "- P(has|given)\n",
    "- P(have|given)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bayes Inference\n",
    "\n",
    "**Describe the relationships among parameter, statistic, sample, and\n",
    "population.**\n",
    " - Population -> Sample -> Statistic -> Parameters\n",
    " - _population_: All observation\n",
    " - _sample_: subsection of the population\n",
    " - _statistics_: calculated from the sample\n",
    " - _parameters_: inferes to the entire population\n",
    "\n",
    "**Understand how Bayes’ Theorem connects to Bayesian inference.**\n",
    "- Bayes Theorem allows us to apply to distribution and connect prior knowledge\n",
    "- continued iteriate process for inference\n",
    "\n",
    "\n",
    "**Describe the posterior distribution.**\n",
    "- Combination of our data and our prior \n",
    "- describes the combination of your priors and evidence(likliehood)\n",
    "- likelihood relates y to your $f(\\theta)$\n",
    "- $f(\\theta | y)$\n",
    "-\n",
    "\n",
    "**Identify methods for choosing a prior and a likelihood.**\n",
    "\n",
    "- conjugacy between your prior and likelihood\n",
    "- likelihood dist should only influence the posterior , develop prior first and then add likelihood\n",
    "\n",
    "**Understand how simulations play such a large role in Bayesian inference.**\n",
    "\n",
    "- conjugacy is limiting, using simulation allows use to use more complicated distribution combinations\n",
    "- computer powers allow more complex problems"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## MCMC\n",
    "\n",
    "**Identify the Markov property.**\n",
    "- __Markov chains__: how a random variable changes from one state to another\n",
    "- __Markov Property__: if i know what is happening at time t, i know just as much about what will happen at t+1, without having to back to t=1.\n",
    "\n",
    "**Describe Monte Carlo simulations.**\n",
    "- powerful way to model complex systems by generating random numbers\n",
    "\n",
    "**Describe how MCMC works.**\n",
    "- MCMC is a method that can find the posterior distribution of our parameter of interest. Specifically, this type of algorithm generates Monte Carlo simulations in a way that relies on the Markov property, then accepts these simulations at a certain rate to get the posterior distribution.\n",
    "\n",
    "- Monte Carlo Methods\n",
    "    - large random sampling process to generate numerical results \n",
    "- Markov Chains\n",
    "    - when we sample random numbers, we're going to rely on the previous random number to help randomly generate the next one\n",
    "- Acceptance Rejection Sampling\n",
    "    - specific type of Monte Carlo\n",
    "    - decide to keep or discard it \n",
    "    - Keeps in going in the right direction\n",
    "\n",
    "**Identify situations where MCMC is beneficial.**\n",
    "- helpful in cases when we don't have conjugate priors/posteriors\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Maximum Likelihood\n",
    "\n",
    "**Understand the Beta Distribution**\n",
    "- distribution of probabilites, binary choice and their probabilities\n",
    "\n",
    "**Describe the concept of \"conjugacy\" and \"conjugate priors\" in Bayesian statistics**\n",
    "- conjugate priors are the linked distribution that allow simple calculations\n",
    "\n",
    "**Set up an example of the Beta-Binomial model using a midterm election example**\n",
    "- in notebook\n",
    "\n",
    "**Calculate the Maximum Likelihood Estimate**\n",
    "- highest point in the posterior distribution\n",
    "\n",
    "**Use the Beta-Binomial model to build our example in a Bayesian framework**\n",
    "- combining a beta prior with a binomial likelihood can generate a beta posterior within Bayesian terms"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Week 11 Neural Networks "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Intro to Neural Networks + Keras \n",
    "\n",
    "\n",
    "### Differentiate between single layer and multi-layer perceptrons\n",
    "- **Single Layer's** have no hidden layer, just input features and a single activation function with an output which can be interpreted as the prediction. Just like the way most models we have talked about work.\n",
    "- **Multi Layer's** have 1 or more hidden layers where data is transformed and new interaction terms are created to be used to predict the output or feed into additional layers.\n",
    "\n",
    "### Define epoch, learning rate, activation function, hidden layer, neuron, weights & bias terms.\n",
    "- **Epoch : ** When our full set of training data fully forward and back propagates through our network. \n",
    "    - Feed the data through the network.\n",
    "    - Calculate the errors.\n",
    "    - Propagate backwards to adjust network to better fit the data via found errors.\n",
    "- **Hidden Layer :** 1 or more neurons that sit in-between our input layer (original features) and our output layer (predictive function) that are responsible for transforming the data.\n",
    "- **Weights : ** Values applied to features as they flow through the network to contribute to interaction.  Weights are randomly initialized and adjusted according to gradient decent on our loss function.  The weights function similar to coefficients in a linear or logistic regression in which the weights multiply the original value in order to affect how much each feature contributes to the interaction term that results from the activation function.\n",
    "- **Bias Terms : ** Constant values that are added in to each neuron.  These are also adjusted the same way the weights are, however they exist on their own and do not _weight_ any other value.\n",
    "- **Activation Function : ** A function on the neuron that takes in the sum of all features after their weights have been applied plus the Bias term and returns a new value that will be used as a feature in the next layer.\n",
    "- **Neuron : ** Neurons are the weights, bias term and activation function.  NNs can have various hidden layers and each hidden layer can have various neurons.  Each neuron has their own unique set of weights and bias term and potentially unique activation function in order to arrive at a single value that represents some kind of combination of all the fed in features.\n",
    "- **Learning Rate : ** How large the steps are that we take when moving through our loss function in order to increase/decrease weights in order to decrease total loss. (Same as gradient Descent)\n",
    "\n",
    "\n",
    "- **Batch :** Often we can not forward then back propagate our entire dataset at once so we divide it up into batches to flow through chunk by chunk\n",
    "- **Iteration :**The process of a single batch flowing forward and backward through the network.\n",
    "\n",
    "\n",
    "### Define Forward and Back Propagation.\n",
    "\n",
    "**Forward propagation** is the process of data flowing through the network in order to arrive at a predicted value.  \n",
    "**Backward Propagation** is the act of optimizing a network be working backwards through it, starting with the errors calculate and identifying the points in the network (weights or nodes) that are contributing most to the error and adjusting them accordingly."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Optimizing Neural Networks & Convolutional Neural Networks\n",
    "\n",
    "\n",
    "\n",
    "### Explain how L1/L2, dropout, and early stopping regularization work and implement these methods in Keras\n",
    "\n",
    "**Regularization**\n",
    "- Incorporating either LASSO or Ridge regularization into back propagation is as simple as adding the regularization term to the loss function (ok, not very simple at all when you look at the math)\n",
    "- L1 typically isn't used in NNs.\n",
    "- L2 is much more popular and sometimes referred to as \"weight decay\". \n",
    "\n",
    "**Dropout**\n",
    "- The process of randomly removing nodes in training epochs to see how it affects the model.  A NN with densly connected layers will have the tendency to overfit so we can utilize drop out in order better understand if nodes should be removed or kept.  (Similar to how Random Forests reduce variance and overfitting.)\n",
    "- Dropouts can occur at any epoch and the models \"constant fear\" of loosing a node at any time prevents the over adjustment of a weight for an epoch.\n",
    "\n",
    "**Early Stopping**\n",
    "- Compares how much the loss function is changes and stops the algorithm once it hits the point where the loss function starts to go up.  This is done with the assumption that the first minimum that was hit it the global minimum. \n",
    "\n",
    "### Describe Gradient Descent with Momentum and Data Augmentation\n",
    "\n",
    "**Gradient Descent with Momentum\n",
    "\n",
    "**Data Augmentation**\n",
    "- Generating more data from existing data.  With pictures this can be the result of transposing, rotating or reflecting and image to create a new version of it.  In addition SMOTE can be used to generate more similar observations."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Identify use cases of Convolutional Neural Networks.\n",
    "- Convolutional NNs consider features related to one another via proximity, this makes them great for assessing pictures because they are able to break down a picture the way humans do, by focusing one specific areas of the photo.\n",
    "\n",
    "### Understand how edge detection works in CNNs\n",
    "- An edge is identified by discontinuity in an image typically in color.  \n",
    "- When we pass our weights window over a panel of data in a picture we transform and map the image into smaller dimensions. \n",
    "- Our Window will have conflicting/balanced weights on each side of it, one side very positive and one side very negative. If there is a significant difference in color/greyscale (what we would interpret as a edge). When the window passes over it, the weights applied on each side of the window will no longer neutral out and instead result in a significant positive or negative value indicating there is a drastic difference in shading from one side of the window to another.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "** Edge Detection**\n",
    "\n",
    "Lets say we have a 5 by 1 image and a window size that is 2 by 1 that we're going to move across out image. _below_.\n",
    "\n",
    "It doesn't matter what value we assign to the pixels as long as different colors are represented by different values. Lets assign a value of `-1` to white and `1` to black.  Our window weights will be `10` and `-10`.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAASgAAABICAYAAABFhGj3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjAsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+17YcXAAABuElEQVR4nO3aMU7DQBCG0RlElxZq2vTxmXIozhR3HIMLUC0NFQJBBMY/q/e6rKxoRpE+aSP3GKMAEt3sPQDAZwQKiCVQQCyBAmIJFBBLoIBYt1890N3nqjpXVR0Oh9PxeNx8KLaxruveI2zmdDrtPQI/sK7r8xjj/v15X/Me1LIs43K5/Opg/J3u3nuEzXif73/r7nWMsbw/d8UDYgkUEEuggFgCBcQSKCCWQAGxBAqIJVBALIECYgkUEEuggFgCBcQSKCCWQAGxBAqIJVBALIECYgkUEEuggFgCBcQSKCCWQAGxBAqIJVBALIECYgkUEEuggFgCBcQSKCCWQAGxBAqIJVBALIECYgkUEEuggFgCBcQSKCCWQAGxBAqIJVBALIECYgkUEEuggFgCBcQSKCCWQAGxBAqIJVBALIECYgkUEEuggFgCBcS6/eqB7j5X1fnt40t3P2070q7uqup57yE2MvNu1d1T71eT/35V9fDRYY8xvv0N3X0ZYyy/NlKYmfebebcq+83KFQ+IJVBArGsD9bjJFDlm3m/m3arsN6Wr/oMC+EuueEAsgQJiCRQQS6CAWAIFxHoFj5VASBr9K8gAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 360x72 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import seaborn as sns\n",
    "%matplotlib inline\n",
    "sns.palplot(sns.color_palette(['#FFFFFF','#FFFFFF', '#000000','#FFFFFF','#FFFFFF']))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "w = np.array([10,-10])\n",
    "\n",
    "# first frame is a white block then another white block\n",
    "f1 = np.array([-1,-1])\n",
    "# second frame is white block then a black block\n",
    "f2 = np.array([-1, 1])\n",
    "# third frame is a black block then a white block\n",
    "f3 = np.array([ 1,-1])\n",
    "f4 = np.array([-1,-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# frame one has no differences in it thus is sums to zero\n",
    "sum(f1*w)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-20"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# frame two HAS differences in it, thus its sum is far away from zero\n",
    "sum(f2*w)\n",
    "# its a negative value because its a light to dark transition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "20"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# frame three HAS differences in it, thus its sum is far away from zero\n",
    "sum(f3*w)\n",
    "# its a positive value because its a dark to light transition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# frame four has no differences in it thus is sums to zero\n",
    "sum(f4*w)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Define and describe \"padding\" and \"strided\" convolutions.\n",
    "- **Padding :** Given that the way edges flow over a picture an aspect of padding can be added.  This is essentially adding boarding cells of neutral values around a picture so that pixels that are in corners or along edges can be considered more often\n",
    "    - In the event there is something important in the corner of an image, without having padding that corner may only be considered once.\n",
    "    - Typically we as humans gravitate our focus towards the center of an image and work outward, they further away from the center objects are in a picture the less we notice them, think about what happens in the corners of pictures.  Its typically not a place you consciously look at when looking at a picture, padding tries to combat NNs from picking up on this same habit.\n",
    "\n",
    "- **Strides :** Stride values determines how many units our window will shift as it flows through the image. \n",
    "    - If a stride is set to 1, then between each window iteration the window will move 1 unit (1 pixel)\n",
    "    - If a stride is set to 2, then the window will shift over 2 units (2 pixels).\n",
    "    \n",
    "### Understand how convolutions operate on volumes.\n",
    "- Volume in terms of a CNN are the aspect of dividing our original image up into several versions.  Typical case is dividing a color image up into three images 1 to represent the Red coloring, 1 to represent the Green coloring, and 1 to represent the Blue coloring (this is done with the RGB color spectrum)\n",
    "- Each color layer will have its own weight window applied to it, after that the results of all 3 weight windows * values will be aggregated into a single matrix.\n",
    "\n",
    "### Define pooling and implement max pooling.\n",
    "- Pooling layers allow us to compress output from the convolution layers.\n",
    "    - Max Pooling is typically the tactic used in the pooling layer.  This identifies and takes the strongest/most important info for retention.  \n",
    "    - Pooling is done independently across channels.  (Each \"node\" has its own unique pooling)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
